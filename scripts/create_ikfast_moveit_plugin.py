#!/usr/bin/env python3

"""
IKFast Plugin Generator for MoveIt

Creates a kinematics plugin using the output of IKFast from OpenRAVE.
This plugin and the move_group node can be used as a general
kinematics service, from within the moveit planning environment, or in
your own ROS node.

Author: Dave Coleman, PickNik Robotics
        Michael Lautman, PickNik Robotics
        Based heavily on the arm_kinematic_tools package by Jeremy Zoss, SwRI
        and the arm_navigation plugin generator by David Butterworth, KAIST

Date: March 2013

"""
"""
Copyright (c) 2013, Jeremy Zoss, SwRI
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
* Neither the name of the Willow Garage, Inc. nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
IABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
"""

import re
import os
import shutil
import argparse


def create_parser():
    parser = argparse.ArgumentParser(
        description="Generate an IKFast MoveIt kinematic plugin"
    )
    parser.add_argument("robot_name", help="The name of your robot")
    parser.add_argument(
        "ikfast_plugin_pkg",
        help="The name of the MoveIt IKFast Kinematics Plugin to be created/updated",
    )
    parser.add_argument(
        "base_link_name",
        help="The name of the base link that was used when generating your IKFast solution",
    )
    parser.add_argument(
        "eef_link_name",
        help="The name of the end effector link that was used when generating your IKFast solution",
    )
    parser.add_argument(
        "ikfast_output_path",
        help="The full path to the analytic IK solution output by IKFast",
    )
    parser.add_argument(
        "--eef_direction",
        type=float,
        nargs=3,
        metavar=("X", "Y", "Z"),
        default=[0, 0, 1],
        help="The end effector's direction vector defined in its own frame, which is used to generate necessary parameters to a IKFast solver of one of the following types: Direction3D, Ray4D, TranslationDirection5D, Translation*AxisAngle4D, and Translation*AxisAngle*Norm4D. When not specified, a unit-z vector, i.e. 0 0 1, is adopted as default",
    )
    return parser


def print_args(args):
    print("Creating IKFastKinematicsPlugin with parameters: ")
    print(f" robot_name:           {args.robot_name}")
    print(f" base_link_name:       {args.base_link_name}")
    print(f" eef_link_name:        {args.eef_link_name}")
    print(f" ikfast_plugin_pkg:    {args.ikfast_plugin_pkg}")
    print(f" ikfast_output_path:   {args.ikfast_output_path}")
    print(
        f" eef_direction:        {args.eef_direction[0]:g} {args.eef_direction[1]:g} {args.eef_direction[2]:g}"
    )
    print("")


def validate_openrave_version(args):
    if not os.path.exists(args.ikfast_output_path):
        raise Exception("Can't find IKFast source code at " + args.ikfast_output_path)

    # Detect version of IKFast used to generate solver code
    solver_version = 0
    with open(args.ikfast_output_path, "r") as src:
        for line in src:
            if line.startswith("/// ikfast version"):
                line_search = re.search("ikfast version (.*) generated", line)
                if line_search:
                    solver_version = int(line_search.group(1), 0) & ~0x10000000
                break
    print(f"Found source code generated by IKFast version {solver_version}")

    # Chose template depending on IKFast version
    if solver_version >= 56:
        setattr(args, "template_version", 61)
    else:
        raise Exception("This converter requires IKFast 0.5.6 or newer.")


def create_ikfast_package(args):
    args.ikfast_plugin_pkg_path = os.path.abspath(args.ikfast_plugin_pkg)
    print(
        f"Createing new package {args.ikfast_plugin_pkg} it in {args.ikfast_plugin_pkg_path}."
    )
    # update pkg name to basename of path
    args.ikfast_plugin_pkg = os.path.basename(args.ikfast_plugin_pkg_path)

    src_path = args.ikfast_plugin_pkg_path + "/src/"
    if not os.path.exists(src_path):
        os.makedirs(src_path)

    include_path = args.ikfast_plugin_pkg_path + "/include/"
    if not os.path.exists(include_path):
        os.makedirs(include_path)


def find_template_dir():
    for candidate in [os.path.dirname(__file__) + "/../templates"]:
        if os.path.exists(candidate) and os.path.exists(candidate + "/ikfast.h"):
            return os.path.realpath(candidate)


def update_ikfast_package(args):
    # Copy the source code generated by IKFast into our src folder
    src_path = args.ikfast_plugin_pkg_path + "/src/"
    solver_file_path = src_path + args.robot_name + "_ikfast_solver.cpp"
    if not os.path.exists(solver_file_path) or not os.path.samefile(
        args.ikfast_output_path, solver_file_path
    ):
        shutil.copy2(args.ikfast_output_path, solver_file_path)

    if not os.path.exists(solver_file_path):
        raise Exception(
            f"Failed to copy IKFast source code from '{args.ikfast_output_path}' to '{solver_file_path}'\n"
            "Manually copy the source file generated by IKFast to this location and re-run"
        )
    # Remember ikfast solver file for update of MoveIt package
    args.ikfast_output_path = solver_file_path

    # Get template folder location
    template_dir = find_template_dir()

    # Copy ikfast header file
    copy_file(
        template_dir + "/ikfast.h",
        args.ikfast_plugin_pkg_path + "/include/ikfast.h",
        "ikfast header file",
    )

    copy_file(
        template_dir + "/ikfast_c_interface.cpp",
        args.ikfast_plugin_pkg_path + "/src/ikfast_c_interface.cpp",
        "ikfast c interface file",
    )


def copy_file(src_path, dest_path, description, replacements=None):
    if not os.path.exists(src_path):
        raise Exception(f"Can't find {description} at '{src_path}'")

    if replacements is None:
        replacements = dict()

    with open(src_path, "r") as f:
        content = f.read()

    # replace templates
    for key, value in replacements.items():
        content = re.sub(key, value, content)

    with open(dest_path, "w") as f:
        f.write(content)
    print(f"Created {description} at '{dest_path}'")


def main():
    parser = create_parser()
    args = parser.parse_args()

    print_args(args)
    validate_openrave_version(args)
    create_ikfast_package(args)
    update_ikfast_package(args)


if __name__ == "__main__":
    main()
